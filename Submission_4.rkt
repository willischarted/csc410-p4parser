#lang rosette
(require racket/match)
(require rosette/lib/synthax)
(define-namespace-anchor anc)
(define ns (namespace-anchor->namespace anc))
;; ----------------------------------------------------------------------------
;;                                  Starter Code
;; ----------------------------------------------------------------------------
;; Returns a syntax object from reading the contents of a file.
(define (file->syntax file)
  (define (read-syntax/count-lines)
    (port-count-lines! (current-input-port))
    (read-syntax))
  (define-values (base _ __) (split-path file))
  (parameterize ([current-namespace (make-base-namespace)])
    (define stx (with-handlers ([exn:fail? (const #f)])
                    (with-input-from-file file read-syntax/count-lines)))
    stx))
(define keywords (list '+ '-           ;Arithmetic
                       'sub1 'add1     ; (sub1 a) is (- a 1) and (add1 a) (+ a 1)
                       'or 'and '! '=  ;Boolean
                       '#t '#f         ;Boolean true/false
                       'max 'min       ;Conditional arithmetic
                       ;; '& '\| '^           ;Bitwise operator
                       '== '>= '<= '> '<   ;Integer comparison
                       'integer? 'boolean? ;Types
                       'void?              ;Void type
                       'if                 ;Conditionals
                       ))
;; Type of the operands of an operator.
;; The void? type represents either integer or boolean.
;; The %top operator is the default operator used as the top
;; operator when starting to parse an expression.
(define (optype? op)
  (match op
    [(or '+ '- 'min 'max '>= '> '< '<= '==) 'integer?]
    [(or 'or 'and '! '=) 'boolean?]
    [(or 'if '%top) 'void?]))
;; Returns true is the syntax objects represents an id
;; that is not a keyword of the language.
(define (is-syntax-of-id stx)
  (if (identifier? stx)
      (let ([x (syntax-e stx)])
      (<= (count (lambda (k) (equal? k x)) keywords) 0))
      false))
;; Builds a list of pairs (identifier, indentfier-type)
;; The type is inferred from the operator above the identifier occurrence
;; so this is not a correct type inference, just a hint.
;; (add-ids top_op stx l) adds the ids encountered in the syntax-object
;; stx  with top-operator top_op into list l.
(struct typed-var (id type) #:transparent #:mutable)
(define (add-ids top_op stx l)
  (if (is-syntax-of-id stx)
      (append l (list (typed-var (syntax->datum stx) (optype? top_op))))
      (let ([expanded-stx (syntax-e stx)])
        (if (list? expanded-stx)
            (foldl (lambda (maybe-id id-list)
                     (add-ids (syntax-e (car expanded-stx))
                              maybe-id id-list))
                   l
                   (cdr expanded-stx))
            l))))
;; Wrapper for add-ids starting from an empty list and
;; a dummy operator that types void
(define (get-ids stx) (remove-duplicates (add-ids '%top stx (list ))) )
;; Create Rosette symbolic definition from identifier + type
(define (make-rosette-decl v)
  (with-syntax
    ([vname (datum->syntax #f (typed-var-id v))]
     [vtype (datum->syntax #f (typed-var-type v))])
    #'(define-symbolic vname vtype)))
(define (make-all-rosette-decl lv)
  (datum->syntax #f (map make-rosette-decl lv)))
;; ----------------------------------------------------------------------------
;;                                    Our Code
;; ----------------------------------------------------------------------------
;; Our make-rosette-simple function
;(define (make-rosette-simple formula) (make-rosette-simple formula (compute-height (syntax->datum formula) 0))) 
(define (make-rosette-simple formula depth) (append
                                       (generate-declarations (determineType (instance-types (syntax->datum formula))))
                                       (list (list
                                              'synthesize
                                              '#:forall (append (list (quote list)) (getvars formula))
                                              '#:guarantee (quasiquote(assert (eq?
                                                                                (unquote (syntax->datum formula))
                                                                                (unquote (append (list (quote gen-expression))
                                                                                                 (list (get-booleans formula))
                                                                                                 (list (get-integers formula))
                                                                                                 (list depth))))))))
                                       ))

;; Evaluates the series of expressions generated by make-rosette-simple
(define (eval-exp expr)(eval (append '(begin) expr)ns))

;; Work in progress - printing the solution
(define (print-solution formula depth) (append
                                        (generate-declarations (determineType (instance-types (syntax->datum formula))))                                        
                                        (list (quasiquote (print-forms (unquote(list
                                              'synthesize
                                              '#:forall (append (list (quote list)) (getvars formula))
                                              '#:guarantee (quasiquote(assert (eq?
                                                                                (unquote (syntax->datum formula))
                                                                                (unquote (append (list (quote gen))
                                                                                                 (get-booleans formula)
                                                                                                 (get-integers formula)))))))))
                                       ))))
;; Our define-synthax function
(define-synthax(gen-expression (booleanvariables ...) (integervariables ...) height)
 #:base (choose booleanvariables ... integervariables ...)
 #:else (choose
         booleanvariables ... integervariables ...
          ((choose >= > <= < + - && ||) (gen-expression (booleanvariables ...)  (integervariables ...) (- height 1))
                        (gen-expression (booleanvariables ...)  (integervariables ...) (- height 1)))
          )
  )

;; Starting with the height of the given formula, repeatedly attempts to synthesize the formula with
;; decreasing depth until we get an unsat. Returns the synthesis with the lowest depth
(define (simplify-exp expr)(simplify-exp-rec expr (compute-height (syntax->datum expr) 0)))
(define (simplify-exp-rec expr n)(if (unsat? (eval-exp (make-rosette-simple expr n)))
                                     (make-rosette-simple expr (+ n 1));todo change to correct output
                                     (simplify-exp-rec expr (- n 1))
                                     )
                                    )

;; ----------------
;;  Type Inference
;; ----------------

;; A helper function to improve on make-all-rosette-decl, using our improved type
;; inferences. Generates the declarations of all variables in the function
(define (generate-declarations variables) (if (null? variables)
                                              (list)
                                              (append (list (list 'define-symbolic (second (car variables)) (car (car variables))))
                                                      (generate-declarations (rest variables)))))

;; A helper function that lists the inferred types of all instances of all variables in the given formula.
;; Variables may appear more than once with different inferred types - other helper functions analyze
;; these types and determine what type each variable should ultimately be assigned
(define (instance-types formula) (process-elements (rest formula) (optype? (car formula))))
(define (process-elements elements type) (if (null? elements)
                                               (list)
                                               (if (list? (car elements))
                                                   (append (instance-types (car elements)) (process-elements (rest elements) type))
                                                   (if (or (number? (car elements)) (boolean? (car elements)))
                                                       (process-elements (rest elements) type)
                                                       (append (list (list type (car elements))) (process-elements (rest elements) type))))))

;; Infers the types of all variables in the formula
(define (determineType lst)(determineTypeHelp (remove-duplicates lst)))
(define (determineTypeHelp lst )(if (empty? lst)
                                   '()
                                   (append
                                        (if (isValid (car lst)(cdr lst))
                                           (if(isVoid (car lst)(cdr lst))
                                              (list(append (list 'integer?) (cdr (car lst))))
                                              (if (equal? (car (car lst)) 'void?)
                                                  '()
                                                  (list(car lst))
                                                  )
                                              )
                                           (raise 'failed #t)
                                       )
                                    (determineTypeHelp (cdr lst)))
                                   ))

;; ------------------
;;  Variable Parsing
;; ------------------

;; A helper function that takes the given formula and returns a list of variables
(define (getvars lst)
  (remove-duplicates (filter notinteger (removeops (syntax->datum lst))))
  )
;; A helper function that returns a list of all the boolean variables in a formula
(define (get-booleans formula) (parse-booleans (generate-declarations (determineType (instance-types (syntax->datum formula))))))
(define (parse-booleans variables) (if (null? variables)
                                           (list)
                                           (if (eq?(third (car variables)) 'integer?)
                                               (parse-booleans (rest variables))
                                               (append (list (second (car variables)))
                                                       (parse-booleans (rest variables))))
                                           ))
;; A helper function that returns a list of all the integer variables in a formula
(define (get-integers formula) (parse-integers (generate-declarations (determineType (instance-types (syntax->datum formula))))))
(define (parse-integers variables) (if (null? variables)
                                           (list)
                                           (if (eq?(third (car variables)) 'boolean?)
                                               (parse-integers (rest variables))
                                               (append (list (second (car variables)))
                                                       (parse-integers (rest variables))))
                                           ))

;; -------------------
;;  Utility Functions
;; -------------------

(define (isVoid item lst)(if (equal? (car item) 'void?)
                             (andmap (lambda (item2) (equal? (cdr item2) (cdr item))) lst)
                             #f))
(define (isValid item lst) (andmap (lambda (item2)
                                                 (if (equal? (cdr item) (cdr item2))
                                                     (or (equal? (car item) 'void?)
                                                         (equal? (car item2) 'void?))
                                                     #t
                                                     ))
                                               lst))
;; A helper function that computes the height of the expression
(define (compute-height formula height) (if (list? formula)
                                            (listmax (map (lambda (f) (compute-height f (+ 1 height))) formula))
                                            height))
(define (listmax lst) (if (null? lst)
                          0
                          (max (car lst) (listmax (rest lst)))))

(define (notinteger i)
  (cond
   [(integer? i) #f]
   [else #t])
  )
(define (flat-list lst)
  (cond ((null? lst) '())
        ((pair? lst)
         (append (flat-list (car lst))
                 (flat-list (cdr lst))))
        (else
         (list lst))))
(define (removeops lst)
  (remove* (list '+ '- 'or 'and 'min 'max '>= '> '< '<= '== '! '= 'if '%top '#t '#f ) (flat-list lst)))

;; ----------------------------------------------------------------------------
;;                                  Check-in 4
;; ----------------------------------------------------------------------------

(println "--------------simplify-expression--------------")
(println "Expression 1")
(pretty-print (simplify-exp (syntax (or (and a b) (and a b)))))
(println "Expression 2")
(pretty-print (simplify-exp (syntax (or (or a b) (or a b)))))
(println "Expression 3")
(pretty-print (simplify-exp (syntax (or (and (and a b) a) (or a c)))))
(println "Expression 4")
(pretty-print (simplify-exp (syntax (and a (< c d)))))
(println "Expression 5")
(pretty-print (simplify-exp (syntax (or (or a (< c d)) (and a (< c d))))))